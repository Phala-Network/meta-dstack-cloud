#!/bin/sh
set -e

read_uevent_property() {
    local file="$1"
    local key="$2"
    while IFS='=' read -r name value; do
        if [ "$name" = "$key" ]; then
            printf "%s" "$value"
            return 0
        fi
    done < "$file"
    return 1
}

find_block_by_property() {
    local key="$1"
    local value="$2"
    local entry
    for entry in /sys/class/block/*; do
        [ -e "$entry/uevent" ] || continue
        local current
        current=$(read_uevent_property "$entry/uevent" "$key" || true)
        if [ "$current" = "$value" ]; then
            printf "/dev/%s" "$(basename "$entry")"
            return 0
        fi
    done
    return 1
}

resolve_block_device() {
    local spec="$1"
    local device=""
    case "$spec" in
    "")
        return 1
        ;;
    PARTLABEL=*)
        device=$(find_block_by_property PARTNAME "${spec#PARTLABEL=}" || true)
        if [ -z "$device" ]; then
            device=$(blkid -o device -l -t "$spec" 2>/dev/null | head -n1 || true)
        fi
        ;;
    PARTUUID=*)
        device=$(find_block_by_property PARTUUID "${spec#PARTUUID=}" || true)
        if [ -z "$device" ]; then
            device=$(blkid -o device -l -t "$spec" 2>/dev/null | head -n1 || true)
        fi
        ;;
    UUID=*|LABEL=*|ID=*)
        device=$(blkid -o device -l -t "$spec" 2>/dev/null | head -n1 || true)
        ;;
    /dev/*)
        device="$spec"
        ;;
    *)
        device="/dev/$spec"
        ;;
    esac
    if [ -n "$device" ] && [ -b "$device" ]; then
        printf "%s" "$device"
        return 0
    fi
    return 1
}

resolve_block_device_with_retry() {
	local spec="$1"
	local attempt=0
	[ -n "$spec" ] || return 1
	while [ $attempt -lt 10 ]; do
		local dev
		dev=$(resolve_block_device "$spec" || true)
		if [ -n "$dev" ] && [ -b "$dev" ]; then
			printf "%s" "$dev"
			return 0
		fi
		sleep 1
		attempt=$((attempt + 1))
	done
	return 1
}

export PATH=/sbin:/bin:/usr/sbin:/usr/bin

mkdir -p /proc
mkdir -p /sys
mkdir -p /run
mount -t proc proc /proc
mount -t sysfs sysfs /sys
mount -t tmpfs tmpfs /run

mkdir -p /dev
mount -t devtmpfs devtmpfs /dev

mkdir -p /dev/pts

ROOT_DEV=""
ROOT_HASH=""
DATA_SIZE=""

# Parse kernel parameters
for param in $(cat /proc/cmdline); do
	case "$param" in
		"dstack.rootfs_hash="*)
			ROOT_HASH="${param#*=}"
			;;
		"dstack.rootfs_size="*)
			DATA_SIZE="${param#*=}"
			;;
		"dstack.rootfs_dev="*)
			ROOT_DEV="${param#*=}"
			;;
		*)
			;;
	esac
done

ROOT_DEV=$(resolve_block_device_with_retry "$ROOT_DEV" || true)
if [ -z "$ROOT_DEV" ]; then
	ROOT_DEV=$(resolve_block_device_with_retry "PARTLABEL=dstack-rootfs" || true)
fi
if [ -z "$ROOT_DEV" ] && [ -b /dev/vda ]; then
	ROOT_DEV=/dev/vda
fi
if [ -z "$ROOT_DEV" ]; then
	echo "Failed to determine root device" >&2
	exec sh
fi
echo "Resolved root device to ${ROOT_DEV}"
ROOT_DIR=/root

echo "Setting up verity device:"
echo "  Root device: ${ROOT_DEV}"
echo "  Root hash: ${ROOT_HASH}"
echo "  Data size: ${DATA_SIZE}"

veritysetup open ${ROOT_DEV} rootfs ${ROOT_DEV} "${ROOT_HASH}" --hash-offset="${DATA_SIZE}"

echo "Mounting rootfs..."
mount -t squashfs /dev/mapper/rootfs ${ROOT_DIR}

mount_move_all() {
    for dir in $@; do
        mount --move /$dir ${ROOT_DIR}/$dir
    done
}
mount_move_all sys proc dev run

echo "Switching to new root..."
exec switch_root ${ROOT_DIR} /sbin/init
